name: Manual Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.2.3). Leave empty for auto-increment.'
        required: false
        type: string
      build_extensions:
        description: 'Build extensions before release'
        required: false
        default: false
        type: boolean

jobs:
  build-linux:
    if: inputs.build_extensions == true
    runs-on: ubuntu-latest
    strategy:
      matrix:
        php_version: ['8.3', '8.4', '8.5']
        arch: ['linux/amd64', 'linux/arm64/v8']
        include:
          - php_version: '8.3'
            php_package: 'php8.3-dev'
          - php_version: '8.4'
            php_package: 'php8.4-dev'
          - php_version: '8.5'
            php_package: 'php8.5-dev'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image for ${{ matrix.arch }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          platforms: ${{ matrix.arch }}
          build-args: |
            PHP_VERSION=${{ matrix.php_version }}
          tags: opa-php-${{ matrix.php_version }}-${{ matrix.arch }}:local
          outputs: type=docker,dest=/tmp/opa-php-${{ matrix.php_version }}-${{ matrix.arch }}.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Extract .so file from container
        run: |
          # Load the image
          docker load -i /tmp/opa-php-${{ matrix.php_version }}-${{ matrix.arch }}.tar
          
          # Create architecture-specific directory name
          ARCH_NAME=$(echo "${{ matrix.arch }}" | sed 's|/v8||g' | sed 's|/|-|g' | tr -d ' ')
          
          # Create output directory
          mkdir -p dist/php${{ matrix.php_version }}/$ARCH_NAME
          
          # Create a temporary container and extract the file
          CONTAINER_ID=$(docker create opa-php-${{ matrix.php_version }}-${{ matrix.arch }}:local)
          
          # Copy from build directory
          docker cp $CONTAINER_ID:/usr/src/opa/modules/opa.so dist/php${{ matrix.php_version }}/$ARCH_NAME/opa.so
          
          # Clean up
          docker rm $CONTAINER_ID
      
      - name: Set artifact name
        id: artifact_name
        run: |
          ARCH_SANITIZED=$(echo "${{ matrix.arch }}" | sed 's|/|-|g' | sed 's|-v8||g' | sed 's|v8||g' | sed 's|-*$||' | tr -d ' ')
          echo "name=opa-php${{ matrix.php_version }}-$ARCH_SANITIZED" >> $GITHUB_OUTPUT
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact_name.outputs.name }}
          path: dist/php${{ matrix.php_version }}/*
          retention-days: 30
  
  build-macos:
    if: inputs.build_extensions == true
    runs-on: macos-latest
    strategy:
      matrix:
        php_version: ['8.3', '8.4', '8.5']
        arch: ['darwin/amd64', 'darwin/arm64']
        include:
          - php_version: '8.3'
            php_brew: 'php@8.3'
          - php_version: '8.4'
            php_brew: 'php@8.4'
          - php_version: '8.5'
            php_brew: 'php@8.5'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install PHP and dependencies
        run: |
          brew install ${{ matrix.php_brew }} autoconf libtool pkg-config lz4
          brew link --force --overwrite ${{ matrix.php_brew }}
          echo "$(brew --prefix ${{ matrix.php_brew }})/bin" >> $GITHUB_PATH
      
      - name: Build extension
        run: |
          phpize
          ./configure --enable-opa
          make
      
      - name: Create release directory
        run: |
          ARCH_NAME=$(echo "${{ matrix.arch }}" | sed 's|/|-|g')
          mkdir -p dist/php${{ matrix.php_version }}/$ARCH_NAME
          cp modules/opa.dylib dist/php${{ matrix.php_version }}/$ARCH_NAME/opa.dylib || \
          cp modules/opa.so dist/php${{ matrix.php_version }}/$ARCH_NAME/opa.dylib
      
      - name: Set artifact name
        id: artifact_name
        run: |
          ARCH_SANITIZED=$(echo "${{ matrix.arch }}" | sed 's|/|-|g' | sed 's|-*$||')
          echo "name=opa-php${{ matrix.php_version }}-$ARCH_SANITIZED" >> $GITHUB_OUTPUT
      
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact_name.outputs.name }}
          path: dist/php${{ matrix.php_version }}/*
          retention-days: 30

  download-latest-artifacts:
    if: inputs.build_extensions == false
    runs-on: ubuntu-latest
    permissions:
      actions: read
    steps:
      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y unzip curl jq
      
      - name: Get latest workflow run ID
        id: workflow_run
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'auto-build-extensions.yml',
              status: 'success',
              per_page: 1
            });
            
            if (runs.workflow_runs.length === 0) {
              core.setFailed('No successful workflow runs found. Please build extensions first or enable "build_extensions" option.');
              return;
            }
            
            const runId = runs.workflow_runs[0].id;
            core.setOutput('run_id', runId);
            console.log(`Found latest successful run: ${runId}`);
      
      - name: Download and extract artifacts
        run: |
          RUN_ID="${{ steps.workflow_run.outputs.run_id }}"
          mkdir -p dist
          
          # Get list of artifacts
          ARTIFACTS_JSON=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/artifacts")
          
          # Extract artifact IDs for opa-php* artifacts
          echo "$ARTIFACTS_JSON" | jq -r '.artifacts[] | select(.name | startswith("opa-php")) | "\(.name)|\(.id)"' | while IFS='|' read -r name id; do
            if [ -z "$name" ] || [ -z "$id" ]; then
              continue
            fi
            echo "Downloading $name (ID: $id)..."
            
            # Get download URL (follow redirects)
            DOWNLOAD_URL=$(curl -s -I -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${id}/zip" | \
              grep -i location | cut -d' ' -f2 | tr -d '\r')
            
            if [ -z "$DOWNLOAD_URL" ]; then
              echo "Failed to get download URL for $name"
              exit 1
            fi
            
            # Download and extract
            curl -s -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "$DOWNLOAD_URL" -o "/tmp/${name}.zip"
            
            unzip -q -o "/tmp/${name}.zip" -d "dist/${name}"
            rm "/tmp/${name}.zip"
            
            echo "Extracted $name to dist/${name}/"
          done
          
          # Verify we got the artifacts
          if [ ! -d "dist/opa-php8.3" ] && [ ! -d "dist/opa-php8.4" ] && [ ! -d "dist/opa-php8.5" ]; then
            echo "Error: No opa-php artifacts were downloaded"
            exit 1
          fi
          
          echo "All artifacts downloaded successfully";

  release:
    needs: [build-linux, build-macos, download-latest-artifacts]
    if: always() && ((needs.build-linux.result == 'success' || needs.build-macos.result == 'success') || needs.download-latest-artifacts.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download artifacts (if built in this workflow)
        if: needs.build-linux.result == 'success' || needs.build-macos.result == 'success'
        uses: actions/download-artifact@v4
        with:
          path: dist
          pattern: opa-php*
          merge-multiple: false
      
      - name: Copy artifacts (if downloaded from previous run)
        if: needs.download-latest-artifacts.result == 'success'
        run: |
          # Artifacts from download-latest-artifacts job are already in dist/
          # Just ensure they're accessible
          mkdir -p dist
          if [ -d "dist/opa-php8.3" ] || [ -d "dist/opa-php8.4" ] || [ -d "dist/opa-php8.5" ]; then
            echo "Artifacts found from previous workflow run"
          fi
      
      - name: Reorganize artifacts
        run: |
          # Reorganize downloaded artifacts into expected structure
          mkdir -p dist/release
          # Debug: show structure
          echo "Artifact structure:"
          find dist -type f \( -name "*.so" -o -name "*.dylib" \) || echo "No .so or .dylib files found"
          find dist -type d || echo "No directories found"
          
          # Find and copy all architecture-specific files
          # Handle multiple possible structures:
          # 1. dist/php{version}/{arch}/opa.{so,dylib} (direct from build jobs)
          # 2. dist/opa-php{version}-{os}-{arch}/{os}-{arch}/opa.{so,dylib} (from downloaded artifacts)
          for version in 8.3 8.4 8.5; do
            # Look for files in the direct build structure
            if [ -d "dist/php${version}" ]; then
              # Copy all architecture-specific files
              find "dist/php${version}" -type f \( -name "*.so" -o -name "*.dylib" \) -exec cp {} "dist/release/" \;
            fi
            
            # Handle artifact structure: dist/opa-php{version}-{os}-{arch}/{os}-{arch}/opa.{so,dylib}
            # Find all artifact directories matching the pattern
            for artifact_dir in dist/opa-php${version}-*; do
              if [ -d "$artifact_dir" ]; then
                # Find and copy all .so and .dylib files recursively
                find "$artifact_dir" -type f \( -name "*.so" -o -name "*.dylib" \) -exec cp {} "dist/release/" \;
              fi
            done
            
            # Also handle legacy artifact structure for backward compatibility
            if [ -d "dist/opa-php${version}" ]; then
              # Try different possible paths
              if [ -d "dist/opa-php${version}/dist/php${version}" ]; then
                find "dist/opa-php${version}/dist/php${version}" -type f \( -name "*.so" -o -name "*.dylib" \) -exec cp {} "dist/release/" \;
              else
                # Try to find the file recursively
                find "dist/opa-php${version}" -type f \( -name "*.so" -o -name "*.dylib" \) -exec cp {} "dist/release/" \;
              fi
            fi
          done
          
          # Verify files exist
          echo "Final release files:"
          ls -la dist/release/ || echo "No files found in dist/release/"
          # Check if we have at least one file
          FILE_COUNT=$(find dist/release -type f \( -name "*.so" -o -name "*.dylib" \) 2>/dev/null | wc -l)
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "Error: No .so or .dylib files found for release!"
            exit 1
          fi
          echo "Found $FILE_COUNT extension file(s) for release"
          # Clean up artifact directories
          rm -rf dist/opa-php* dist/php8.*
      
      - name: Generate version tag
        id: version
        run: |
          # Fetch all tags
          git fetch --tags || true
          
          if [ -n "${{ inputs.version }}" ]; then
            # Use provided version
            NEW_VERSION="${{ inputs.version }}"
            # Ensure it starts with 'v'
            if [[ ! "$NEW_VERSION" =~ ^v ]]; then
              NEW_VERSION="v${NEW_VERSION}"
            fi
          else
            # Get the latest tag
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            
            if [ -z "$LATEST_TAG" ]; then
              # No tags exist, start with v0.0.1
              echo "No existing tags found, starting with v0.0.1"
              NEW_VERSION="v0.0.1"
            else
              echo "Latest tag: $LATEST_TAG"
              
              # Extract version number (remove 'v' prefix)
              VERSION_NUM=$(echo "$LATEST_TAG" | sed 's/^v//')
              
              # Split version into parts
              IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUM"
              
              # Handle cases where version might not have all parts
              MAJOR=${MAJOR:-0}
              MINOR=${MINOR:-0}
              PATCH=${PATCH:-0}
              
              # Increment patch version
              PATCH=$((PATCH + 1))
              
              # Create new version
              NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
            fi
          fi
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_VERSION" >> $GITHUB_OUTPUT
      
      - name: Generate release description
        id: release_desc
        run: |
          # Fetch all tags
          git fetch --tags || true
          
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          DESCRIPTION="## Release ${{ steps.version.outputs.version }}"
          DESCRIPTION="${DESCRIPTION}"$'\n\n'
          DESCRIPTION="${DESCRIPTION}Release created from commit: [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})"
          DESCRIPTION="${DESCRIPTION}"$'\n\n'
          
          if [ -z "$LATEST_TAG" ]; then
            DESCRIPTION="${DESCRIPTION}### Changes in this release"$'\n'
            DESCRIPTION="${DESCRIPTION}$(git log --oneline -20 --pretty=format:'- %s (%h)')"
          else
            DESCRIPTION="${DESCRIPTION}### Changes since $LATEST_TAG"$'\n'
            DESCRIPTION="${DESCRIPTION}$(git log ${LATEST_TAG}..HEAD --oneline --pretty=format:'- %s (%h)' || echo '- No commits found')"
            DESCRIPTION="${DESCRIPTION}"$'\n\n'
            DESCRIPTION="${DESCRIPTION}### Files Changed"$'\n'
            CHANGED_FILES=$(git diff --name-status ${LATEST_TAG}..HEAD | head -20 || echo "No changes")
            DESCRIPTION="${DESCRIPTION}\`\`\`"$'\n'
            DESCRIPTION="${DESCRIPTION}${CHANGED_FILES}"$'\n'
            DESCRIPTION="${DESCRIPTION}\`\`\`"
          fi
          
          DESCRIPTION="${DESCRIPTION}"$'\n\n'
          DESCRIPTION="${DESCRIPTION}### Built Extensions"$'\n'
          DESCRIPTION="${DESCRIPTION}This release includes extensions for multiple architectures:"$'\n\n'
          DESCRIPTION="${DESCRIPTION}**Linux:**"$'\n'
          DESCRIPTION="${DESCRIPTION}- \`linux-amd64\` (x86_64)"$'\n'
          DESCRIPTION="${DESCRIPTION}- \`linux-arm64\` (ARM64)"$'\n\n'
          DESCRIPTION="${DESCRIPTION}**macOS:**"$'\n'
          DESCRIPTION="${DESCRIPTION}- \`darwin-amd64\` (Intel Macs)"$'\n'
          DESCRIPTION="${DESCRIPTION}- \`darwin-arm64\` (Apple Silicon)"$'\n\n'
          DESCRIPTION="${DESCRIPTION}Extensions are available for PHP 8.3, 8.4, and 8.5."$'\n\n'
          DESCRIPTION="${DESCRIPTION}### Installation"$'\n'
          DESCRIPTION="${DESCRIPTION}Download the appropriate extension file for your PHP version and architecture from the assets below."
          
          echo "description<<EOF" >> $GITHUB_OUTPUT
          echo "$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.version }}
          body: ${{ steps.release_desc.outputs.description }}
          files: |
            dist/release/*.so
            dist/release/*.dylib
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
